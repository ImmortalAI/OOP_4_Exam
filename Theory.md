1. Описание языка программирования С# и платформы .NET. 

C# является языком с Си-подобным синтаксисом и близок в этом отношении к C++ и Java.

C# является объектно-ориентированным и в этом плане много перенял у Java и С++. Например, C# поддерживает полиморфизм, наследование, перегрузку операторов, статическую типизацию.

Можно выделить следующие основные черты .NET:

- Поддержка нескольких языков. 
  Основой платформы является общеязыковая среда исполнения Common Language Runtime (CLR), ; при компиляции код на любом из этих языков компилируется в сборку на общем языке CIL (Common Intermediate Language).
- Кроссплатформенность. 
  .NET является переносимой платформой (с некоторыми ограничениями).
- Мощная библиотека классов. 
  .NET представляет единую для всех поддерживаемых языков библиотеку классов.
- Разнообразие технологий. 
  Общеязыковая среда исполнения CLR и базовая библиотека классов являются основой для целого стека технологий, которые разработчики могут задействовать при построении тех или иных приложений. Например, ADO.NET и Entity Framework Core для работы с базами данных, для построения графических приложений - технология WPF и WinUI (попроще, Windows Forms), для разработки кроссплатформенных мобильных и десктопных приложений - Xamarin/MAUI, для создания веб-сайтов и веб-приложений - ASP.NET и т.д.
- Производительность. 
  Согласно ряду тестов веб-приложения на .NET в ряде категорий сильно опережают веб-приложения, построенные с помощью других технологий.

Нередко приложение, созданное на C#, называют **управляемым кодом** (managed code). Это значит, что данное приложение создано на основе платформы .NET и поэтому управляется общеязыковой средой CLR, которая загружает приложение и при необходимости очищает память.

Код на C# компилируется в приложения или сборки с расширениями exe или dll на языке CIL. Далее при запуске на выполнение подобного приложения происходит JIT-компиляция (Just-In-Time) в машинный код, который затем выполняется. При этом, поскольку наше приложение может быть большим и содержать кучу инструкций, в текущий момент времени будет компилироваться лишь та часть приложения, к которой непосредственно идет обращение. Если мы обратимся к другой части кода, то она будет скомпилирована из CIL в машинный код. При том уже скомпилированная часть приложения сохраняется до завершения работы программы. В итоге это повышает производительность.

2. Основные принципы объектно-ориентированного программирования и примеры их реализации в языке программирования C#.

Объектно-ориентированное программирование основано на четырех основных принципах:

- Абстракция: абстрактное поведение объектов обобщается в классах
- Инкапсуляция данных: свойства и методы инкапсулируются в виде классов и скрыты от внешнего доступа.
- Наследование: свойства и методы могут быть унаследованы одним классом от другого класса
- Полиморфизм: множество форм - объекты могут принимать различные формы в зависимости от их использования

TODO: Пример

```csharp
class Program{
    public static void Main(string[] argv){

    }
}
```

3. Ссылочный и значимый типы данных. Примеры, объявление и инициализация переменных. Понятие nullable типов данных.

Все типы данных можно разделить на типы значений, еще называемые значимыми типами (value types), и ссылочные типы (reference types).

Типы значений:

- Целочисленные типы (`byte`, `sbyte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`)
- Типы с плавающей запятой (`float`, `double`)
- Тип `decimal`
- Тип `bool`
- Тип `char`
- Перечисления `enum`
- Структуры (`struct`)

Ссылочные типы:

- Тип `object`
- Тип `string`
- Классы (`class`)
- Интерфейсы (`interface`)
- Делегаты (`delegate`)

Для понимания разницы между ними необходимо знать организацию памяти в .NET. Здесь память делится на два типа: стек и куча (heap). 

Параметры и переменные метода, которые представляют типы значений, размещают свое значение в стеке. Причем в стеке будет храниться непосредственное значение этого параметра или переменной. 

Ссылочные типы хранятся в куче, или хипе, которую можно представить как неупорядоченный набор разнородных объектов. Физически это остальная часть памяти, которая доступна процессу.

При создании объекта ссылочного типа в стеке помещается ссылка на адрес в куче (хипе). Когда объект ссылочного типа перестает использоваться, в дело вступает автоматический сборщик мусора: он видит, что на объект в хипе нету больше ссылок, условно удаляет этот объект и очищает память - фактически помечает, что данный сегмент памяти может быть использован для хранения других данных.

TODO: Пример

Кроме стандартных значений типа чисел, строк, язык C# имеет специальное значение - `null`, которое фактически указывает на отсутствие значения как такового, отсутствие данных. До сих пор значение `null` выступает как значение по умолчанию для ссылочных типов.

В различных ситуациях бывает удобно, чтобы объекты могли принимать значение null, то есть были бы не определены. Стандартный пример - работа с базой данных, которая может содержать значения null. И мы можем заранее не знать, что мы получим из базы данных - какое-то определенное значение или же null.

При этом подобные ссылочные типы, которые допускают присвоение значения null, доступно только в nullable-контексте. Для nullable-контекста характерны следующие особенности:

- Переменную ссылочного типа следует инициализировать конкретным значением, ей не следует присваивать значение null
- Переменной ссылочного nullable-типа можно присвоить значение null, но перед использование необходимо проверять ее на значение null.

```csharp
string? name = null;
PrintUpper(name); // NullReferenceException

void PrintUpper(string? text)
{
    Console.WriteLine(text.ToUpper());
}
```

В отличие от ссылочных типов переменным/параметрам значимых типов нельзя напрямую присвоить значение `null`. Чтобы присвоения переменной или параметру значимого типа значения `null`, эти переменная/параметр значимого типа должны представлять тип nullable.

Стоит отметить, что фактически запись ? для значимых типов является упрощенной формой использования структуры `System.Nullable<T>`.

Структура `Nullable<T>` имеет два свойства:

`Value` : значение объекта

`HasValue` : возвращает `true`, если объект хранит некоторое значение, и `false`, если объект равен `null`.

4. Преобразование ссылочных и значимых типов данных. 

TODO: пока пропуск

5. Массивы (одномерные, многомерные, ступенчатые\рваные\зубчатые). Объявление и инициализация массивов. Методы класса Array

**Массив** представляет набор однотипных данных. Объявление массива похоже на объявление переменной за тем исключением, что после указания типа ставятся квадратные скобки:

```
тип_переменной[] название_массива;
```

Например, определим массив целых чисел:

```csharp
int[] numbers;

int[] numbers2 = new int[4] { 1, 2, 3, 5 };
 
int[] numbers3 = new int[] { 1, 2, 3, 5 };
 
int[] numbers4 = new[] { 1, 2, 3, 5 };
 
int[] numbers5 = { 1, 2, 3, 5 };
```

Массивы характеризуются таким понятием как **ранг** или количество измерений. Выше мы рассматривали массивы, которые имеют одно измерение (то есть их ранг равен 1) - такие массивы можно представлять в виде ряда (строки или столбца) элемента. Но массивы также бывают многомерными. У таких массивов количество измерений (то есть ранг) больше 1.

Массивы которые имеют два измерения (ранг равен 2) называют **двухмерными**. Например, создадим одномерный и двухмерный массивы, которые имеют одинаковые элементы:

```csharp
int[] numbers1 = new int[] { 0, 1, 2, 3, 4, 5 };
 
int[,] numbers2 = { { 0, 1, 2 }, { 3, 4, 5 } };
```

От многомерных массивов надо отличать массив массивов или так называемый **"зубчатый массив"**:

```csharp
int[][] numbers = { 
    new int[] { 1, 2 }, 
    new int[] { 1, 2, 3 }, 
    new int[] { 1, 2, 3, 4, 5 } 
};
```

Используя вложенные циклы, можно перебирать зубчатые массивы. Например:

```csharp
foreach(int[] row in numbers)
{
    foreach(int number in row)
    {
        Console.Write($"{number} \t");
    }
    Console.WriteLine();
}
```

**Основные понятия массивов**

- Ранг (rank): количество измерений массива
- Длина измерения (dimension length): длина отдельного измерения массива
- Длина массива (array length): количество всех элементов массива

**Методы класса Array**

* `GetLength(int)` - длина массива
* `GetUpperBound(int)` - индекс последнего элемента **в указанной размерности**

6. Условные операторы и операторы цикла. Примеры.

**Условные конструкции** - один из базовых компонентов многих языков программирования, которые направляют работу программы по одному из путей в зависимости от определенных условий.

**`if`..`else`**

```csharp
string name = "Alex";
 
if (name == "Tom")
    Console.WriteLine("Вас зовут Tomas");
else if (name == "Bob")
    Console.WriteLine("Вас зовут Robert");
else if (name == "Mike")
    Console.WriteLine("Вас зовут Michael");
else
    Console.WriteLine("Неизвестное имя");
```

**Тернарная операция**

```csharp
int x = 3;
int y = 2;
 
int z = x < y ? (x+y) : (x-y);
Console.WriteLine(z);   // 1
```

**Циклы** являются управляющими конструкциями, позволяя в зависимости от определенных условий выполнять некоторое действие множество раз. В C# имеются следующие виды циклов:

- `for`
- `foreach`
- `while`
- `do`..`while`

```csharp
for (int i = 1; i < 4; i++)
{
    Console.WriteLine(i);
}
```

```csharp
int i = 6;
do
{
    Console.WriteLine(i);
    i--;
}
while (i > 0);
```

```csharp
int i = 6;
while (i > 0)
{
    Console.WriteLine(i);
    i--;
}
```

```csharp
foreach(char c in "Tom")
{
    Console.WriteLine(c);
}
```

Иногда возникает ситуация, когда требуется выйти из цикла, не дожидаясь его завершения. В этом случае мы можем воспользоваться оператором `break`. А если мы хотим, чтобы при проверке цикл не завершался, а просто пропускал текущую итерацию, тогда мы можем воспользоваться оператором `continue`.

7. Классы. Определение класса, объявление и инициализация переменных типа класса. Элементы класса. Примеры.

Описанием объекта является **класс**, а объект представляет **экземпляр** этого класса.

По сути класс представляет новый тип, который определяется пользователем. Класс определяется с помощью ключевого слова `class`. Класс может хранить некоторые данные, для этого в классе применяются поля. 

```csharp
class Person 
{
    public string name = "Undefined";
    public int age;
 
    public void Print()
    {
        Console.WriteLine($"Имя: {name}  Возраст: {age}");
    }
}
```

В классе `Person` определен метод `Print()`. Методы класса имеют доступ к его полям, и в данном случае мы обращаемся к полям класса `name` и `age` для вывода их значения на консоль. Чтобы этот метод был виден вне класса, он также определен с модификатором `public`.

После определения класса мы можем создавать его объекты. Для создания объекта применяются **конструкторы**.

```csharp
new конструктор_класса(параметры_конструктора);
```

Кроме обычных методов в языке C# предусмотрены специальные методы доступа, которые называют **свойства**. Они обеспечивают простой доступ к полям классов и структур, чтобы узнать их значение или выполнить их установку.

```csharp
public string Property { get; set; }
```

8. Модификаторы передаваемых в методы параметров (in, out, ref). Примеры. 

При **передаче параметров по ссылке** перед параметрами используется модификатор `ref`

```csharp
void Increment(ref int n)
{
    n++;
}
 
int number = 5;
Increment(ref number); // number = 6
```

Параметры могут быть также **выходными**. Чтобы сделать параметр выходным, перед ним ставится модификатор `out`:

```csharp
void Sum(int x, int y, out int result)
{
    result = x + y;
}
 
Sum(10, 15, out int number); // number = 25
```

При этом, если нам неизвестен тип значений, которые будут присвоены параметрам, то мы можем для их определения использовать оператор `var`:

```csharp
void GetRectangleData(int width, int height, out int rectArea, out int rectPerimeter)
{
    rectArea = width * height;  
    rectPerimeter = (width + height) * 2; 
}

GetRectangleData(10, 20, out var area, out var perimeter);
```

Кроме выходных параметров с модификатором `out` метод может использовать **входные параметры** с модификатором `in`. Модификатор `in` указывает, что данный параметр будет передаваться в метод по ссылке, однако внутри метода его значение параметра нельзя будет изменить. Например:

```csharp
void GetRectangleData(in int width, in int height, out int rectArea, out int rectPerimeter)
{
    //width = 25; // нельзя изменить, так как width - входной параметр
    rectArea = width * height;      
    rectPerimeter = (width + height) * 2;
}
 
int w = 10;
int h = 20;
GetRectangleData(w, h, out var area, out var perimeter);
```

9. Организация наследования в языке программирования C#. Механизмы запрета наследования.

**Наследование** (inheritance) является одним из ключевых моментов ООП. Благодаря наследованию один класс может унаследовать функциональность другого класса.

```csharp
class Person
{
    private string _name = "";
 
    public string Name
    {
        get { return _name; }
        set { _name = value; }
    }
    public void Print()
    {
        Console.WriteLine(Name);
    }
}

class Employee : Person
{
     
}
```

Для класса `Employee` базовым является `Person`, и поэтому класс `Employee` наследует все те же свойства, методы, поля, которые есть в классе `Person`. Единственное, что не передается при наследовании, это конструкторы базового класса с параметрами.

Таким образом, наследование реализует отношение is-a (является), объект класса Employee также является объектом класса Person

```csharp
Person person = new Employee { Name = "Tom" };
```

По умолчанию все классы наследуются от базового класса `Object`, даже если мы явным образом не устанавливаем наследование. Поэтому выше определенные классы `Person` и `Employee` кроме своих собственных методов, также будут иметь и методы класса `Object`: `ToString()`, `Equals()`, `GetHashCode()` и `GetType()`.

Все классы по умолчанию могут наследоваться. Однако здесь есть ряд ограничений:

- Не поддерживается множественное наследование, класс может наследоваться только от одного класса.
- При создании производного класса надо учитывать тип доступа к базовому классу - тип доступа к производному классу должен быть таким же, как и у базового класса, или более строгим. То есть, если базовый класс у нас имеет тип доступа internal, то производный класс может иметь тип доступа internal или private, но не public.
- Если класс объявлен с модификатором sealed, то от этого класса нельзя наследовать и создавать производные классы. Например, следующий класс не допускает создание наследников

  ```csharp
  sealed class Admin
  { }
  ```

- Нельзя унаследовать класс от статического класса.

10. Специальные методы: конструктор и финализатор. Объявление и вызов. Наследование специальных методов.

Как правило, **конструктор** выполняет инициализацию объекта. При этом если в классе определяются свои конструкторы, то он лишается конструктора по умолчанию.

На уровне кода конструктор представляет метод, который называется по имени класса, который может иметь параметры, но для него не надо определять возвращаемый тип.

```csharp
Person sam = new("Sam", 25); 
sam.Print(); // Имя: Sam  Возраст: 25

class Person 
{
    public string name;
    public int age;
    public Person()
    {
        Console.WriteLine("Создание объекта Person");
        name = "Tom";
        age = 37;
    }
    public void Print() => Console.WriteLine($"Имя: {name}  Возраст: {age}");
}
```

Если конструкторов несколько, мы можем не дублировать их функциональность, а просто обращаться из одного конструктора к другому через ключевое слово this, передавая нужные значения для параметров:

```csharp
class Person 
{
    public string name;
    public int age;
    public Person() : this("Неизвестно")
    { }
    public Person(string name) : this(name, 18)
    { }
    public Person(string name, int age)
    {
        this.name = name;
        this.age = age;
    }
    public void Print() => Console.WriteLine($"Имя: {name}  Возраст: {age}");
}
```

Большинство объектов, используемых в программах на C#, относятся к **управляемым** или **managed-коду**. Такие объекты управляются CLR и легко очищаются сборщиком мусора. Однако вместе с тем встречаются также и такие объекты, которые задействуют **неуправляемые объекты** (подключения к файлам, базам данных, сетевые подключения и т.д.).

Освобождение неуправляемых ресурсов подразумевает реализацию одного из двух механизмов:

* Создание деструктора
* Реализация классом интерфейса `System.IDisposable`

Например, определим в классе Person простейший деструктор:

```csharp
class Person
{
    public string Name { get;}
    public Person(string name) => Name = name;
 
    ~Person()
    {
        Console.WriteLine($"{Name} has deleted");
    }
}
```

На деле при очистке сборщик мусора вызывает не деструктор, а метод `Finalize`. Данный метод уже определен в базовом для всех типов классе `Object`, однако данный метод нельзя так просто переопределить, и фактическая его реализация происходит через создание деструктора.

Обратите внимание, что даже после завершения метода и соответственно удаления из стека ссылки на объект `Person` в куче, может не последовать немедленного вызова деструктора. С .NET 5 и в последующих версиях при завершении программы деструкторы также не вызываются. Поэтому для очистки памяти и вызова деструктора применяется метод `GC.Collect`.

Второй подход к освобождению неуправляемых ресурсов - интерфейс `IDisposable`

Интерфейс `IDisposable` объявляет один единственный метод `Dispose`, в котором при реализации интерфейса в классе должно происходить освобождение неуправляемых ресурсов. 

```csharp
Test();
 
void Test()
{
    Person? tom = null;
    try
    {
        tom = new Person("Tom");
    }
    finally
    {
        tom?.Dispose();
    }
}
 
public class Person : IDisposable
{
    public string Name { get;}
    public Person(string name) => Name = name;
 
    public void Dispose()
    {
        Console.WriteLine($"{Name} has been disposed");
    }
}
```

Microsoft предлагает нам использовать следующий формализованный шаблон с комбинацией обоих методов:



```csharp
public class SomeClass: IDisposable
{
    private bool disposed = false;
 
    // реализация интерфейса IDisposable.
    public void Dispose()
    {
        // освобождаем неуправляемые ресурсы
        Dispose(true);
        // подавляем финализацию
        GC.SuppressFinalize(this);
    }
 
    protected virtual void Dispose(bool disposing)
    {
        if (disposed) return;
        if (disposing)
        {
            // Освобождаем управляемые ресурсы
        }
        // Освобождаем неуправляемые объекты
        disposed = true;
    }
 
    // Деструктор
    ~SomeClass()
    {
        Dispose (false);
    }
}
```

Общие рекомендации по использованию `Finalize` и `Dispose`:

* Деструктор следует реализовывать только у тех объектов, которым он действительно необходим, так как метод `Finalize` оказывает **сильное влияние на производительность**;
* После вызова метода Dispose необходимо блокировать у объекта вызов метода `Finalize` с помощью `GC.SuppressFinalize(this)`;
* При создании производных классов от базовых, которые реализуют интерфейс `IDisposable`, следует также вызывать метод `Dispose` базового класса;
* Отдавайте предпочтение **комбинированному шаблону**, реализующему как метод `Dispose`, так и деструктор.

11. Виртуальные элементы класса. Переопределение методов и операторов. Примеры.

При наследовании нередко возникает необходимость изменить в классе-наследнике функционал метода, который был унаследован от базового класса. В этом случае класс-наследник может переопределять методы и свойства базового класса.

Те методы и свойства, которые мы хотим сделать доступными для переопределения, в базовом классе помечается модификатором `virtual`. Такие методы и свойства называют **виртуальными**.

А чтобы переопределить метод в классе-наследнике, этот метод определяется с модификатором `override`. Переопределенный метод в классе-наследнике должен иметь тот же набор параметров, что и виртуальный метод в базовом классе.

```csharp
Person bob = new Person("Bob");
bob.Print(); // Bob
 
Employee tom = new Employee("Tom", "Microsoft");
tom.Print(); // Tom работает в Microsoft

class Person
{
    public string Name { get; set; }
    public Person(string name)
    {
        Name = name;
    }
    public virtual void Print()
    {
        Console.WriteLine(Name);
    }
}
class Employee : Person
{
    public string Company { get; set; }
    public Employee(string name, string company)
        : base(name)
    {
        Company = company;
    }
    public override void Print()
    {
        Console.WriteLine($"{Name} работает в {Company}");
    }
}
```

При переопределении виртуальных методов следует учитывать ряд ограничений:

* Виртуальный и переопределенный методы должны иметь один и тот же модификатор доступа. То есть если виртуальный метод определен с помощью модификатора `public`, то и переопределенный метод также должен иметь модификатор `public`.
* Нельзя переопределить или объявить виртуальным статический метод.

Также как и методы, можно переопределять свойства:

```csharp
class Person
{
    int age = 1;
    public virtual int Age
    {
        get => age;
        set{ if(value > 0 && value < 110) age = value; }
    }
    public string Name { get; set; }
    public Person(string name)
    {
        Name = name;
    }
    public virtual void Print() => Console.WriteLine(Name);
}
class Employee : Person
{
    public override int Age
    {
        get => base.Age;
        set { if (value > 17 && value < 110) base.Age = value; }
    }
    public string Company { get; set; }
    public Employee(string name, string company)
        : base(name)
    {
        Company = company;
        base.Age = 18;
    }
}
```

Определение операторов заключается в определении в классе, для объектов которого мы хотим определить оператор, специального метода:

```csharp
public static возвращаемый_тип operator оператор(параметры)
{  }
```

12. Абстрактные классы. Абстрактные элементы классов. 

**Абстрактный класс** похож на обычный класс. Он также может иметь переменные, методы, конструкторы, свойства. Единственное, что при определении абстрактных классов используется ключевое слово `abstract`. Например, определим абстрактный класс, который представляет некое транспортное средство:


```csharp
abstract class Transport
{
    public void Move()
    {
        Console.WriteLine("Транспортное средство движется");
    }
}
```

Но главное отличие абстрактных классов от обычных состоит в том, что мы **не можем** использовать конструктор абстрактного класса для создания экземпляра класса. 

Кроме обычных свойств и методов абстрактный класс может иметь **абстрактные члены классов**, которые определяются с помощью ключевого слова `abstract` и не имеют никакого функционала. В частности, абстрактными могут быть:

- Методы
- Свойства
- Индексаторы
- События

Абстрактные члены классов не должны иметь модификатор `private`. При этом производный класс обязан переопределить и реализовать все абстрактные методы и свойства, которые имеются в базовом абстрактном классе. При переопределении в производном классе такой метод или свойство также объявляются с модификатором `override`. Также следует учесть, что если класс имеет хотя бы один абстрактный метод (или абстрактные свойство, индексатор, событие), то этот класс должен быть определен как **абстрактный**.

Хрестоматийным примером является система геометрических фигур.

```csharp
abstract class Shape
{
    public abstract double GetPerimeter();
    public abstract double GetArea();
}
class Rectangle : Shape
{
    public float Width { get; set; }
    public float Height { get; set; }
 
    public override double GetPerimeter() => Width * 2 + Height * 2;
    public override double GetArea() => Width * Height;
}
class Circle : Shape
{
    public double Radius { get; set; }
 
    public override double GetPerimeter() => Radius * 2 * 3.14;
    public override double GetArea() => Radius * Radius * 3.14;
}
```

13. Интерфейсы. Интерфейсные ссылки. Механизм внедрения зависимостей Dependency Injection (DI).

Для определения интерфейса используется ключевое слово `interface`. Как правило, названия интерфейсов в C# начинаются с заглавной буквы I, например, `IComparable`, `IEnumerable` (так называемая венгерская нотация), однако это не обязательное требование, а больше стиль программирования.

Интерфейсы могут определять следующие сущности:

* Методы
* Свойства
* Индексаторы
* События
* Статические поля и константы (начиная с версии C# 8.0)

Методы и свойства интерфейса могут не иметь реализации, в этом они сближаются с абстрактными методами и свойствами абстрактных классов.

Еще один момент в объявлении интерфейса: если его члены - методы и свойства не имеют модификаторов доступа, то фактически по умолчанию доступ public, так как цель интерфейса - определение функционала для реализации его классом.

```csharp
interface IMovable
{
    const int minSpeed = 0;     // минимальная скорость
    private static int maxSpeed = 60;   // максимальная скорость
    public void Move();
    protected internal string Name { get; set; }    // название
    public delegate void MoveHandler(string message);  // определение делегата для события
    public event MoveHandler MoveEvent;    // событие движения
}
```

Рассмотрим пример:

```csharp
// Все объекты Message являются объектами IMessage
IMessage hello = new Message("Hello!");
Console.WriteLine(hello.Text); // Hello!
 
interface IMessage
{
    string Text { get; set; }
}
interface IPrintable
{
    void Print();
}
class Message : IMessage, IPrintable
{
    public string Text { get; set; }
    public Message(string text) => Text = text;
    public void Print()=> Console.WriteLine(Text);
}
```

**Dependency injection** (DI) или внедрение зависимостей представляет механизм, который позволяет сделать компоненты программы слабосвязанными, а всю программу в целом более гибкой, более адаптируемой и расширяемой.

```csharp
var logger = new Logger(new SimpleLogService());
logger.Log("Hello METANIT.COM");
 
logger = new Logger(new GreenLogService());
logger.Log("Hello METANIT.COM");
 
interface ILogService
{
    void Write(string message);
}
// простой вывод на консоль
class SimpleLogService : ILogService
{
    public void Write(string message) => Console.WriteLine(message);
}
// сервис, который выводит сообщение зеленым цветом
class GreenLogService : ILogService
{
    public void Write(string message)
    {
        var defaultColor = Console.ForegroundColor;
        Console.ForegroundColor = ConsoleColor.DarkGreen;
        Console.WriteLine(message);
        Console.ForegroundColor = defaultColor;
    }
}
class Logger
{
    ILogService logService;
    public Logger(ILogService logService) => this.logService = logService;
    public void Log(string message) => logService.Write($"{DateTime.Now}  {message}");
}
```

Класс `Logger` не зависит от конкретной реализации класса `SimpleLogService` - это может быть любая реализация интерфейса `ILogService`. Кроме того, создание сервиса логгера выносится во внешний код. Класс `Logger` больше ничего не знает о сервисе, кроме того, что у него есть метод `Write`, который позволяет логгировать сообщение куда-то каким-то образом.

Все сервисы или зависимости хранятся в механизме DI в .NET хранятся в специальной коллекции сервисов, которая представляет тип IServiceCollection. .NET предоставляет встроенную реализацию этого интерфейса - класс ServiceCollection.

Для получения добавленного сервиса нам нужен провайдер сервисов `IServiceProvider`. Для его получения у коллекции сервисов вызывается метод `BuildServiceProvider()`, который возвращает встроенную реализацию провайдера - объект `ServiceProvider`.

```csharp
using Microsoft.Extensions.DependencyInjection;
 
var services = new ServiceCollection()
    .AddTransient<ILogService, SimpleLogService>()
    .AddTransient<Logger>();
 
using var serviceProvider = services.BuildServiceProvider();
// получаем объект Logger
Logger? logger = serviceProvider.GetService<Logger>();
logger?.Log("Hello");
 
interface ILogService
{
    void Write(string message);
}
class SimpleLogService : ILogService
{
    public void Write(string message) => Console.WriteLine(message);
}
class Logger
{
    ILogService? logService;
    public Logger(ILogService? logService) => this.logService = logService;
    public void Log(string message) => logService?.Write($"{DateTime.Now}  {message}");
}
```

14. Универсальные шаблоны/Generic/Обобщения. Определение классов, содержащих универсальные шаблоны, и объявление переменных типов данных классов. Отличия от механизма boxing\unboxing

Рассмотрим пример:

```csharp
Person tom = new Person(546, "Tom");
Person bob = new Person("abc123", "Bob");
 
int tomId = (int)tom.Id;
string bobId = (string) bob.Id;
 
Console.WriteLine(tomId);   // 546
Console.WriteLine(bobId);   // abc123

class Person
{
    public object Id { get;}
    public string Name { get;}
    public Person(object id, string name)
    {
        Id = id; 
        Name = name;
    }
}
```

Все вроде замечательно работает, но такое решение является не очень оптимальным. Дело в том, что в данном случае мы сталкиваемся с такими явлениями как **упаковка** (boxing) и **распаковка** (unboxing).

Так, при передаче в конструктор значения типа `int`, происходит упаковка этого значения в тип `Object`. Чтобы обратно получить данные в переменную типов `int`, необходимо выполнить распаковку с явным приведением типа. Причем мы можем не знать, какой именно объект представляет `Id`, и при попытке получить число в данном случае мы столкнемся с исключением `InvalidCastException`.

Для решения таких проблем в язык C# была добавлена поддержка **обобщенных типов** (также часто называют универсальными типами). Обобщенные типы позволяют указать конкретный тип, который будет использоваться. Поэтому определим класс Person как обобщенный:

```csharp
Person<int> tom = new Person<int>(546, "Tom");
Person<string> bob = new Person<string>("abc123", "Bob");
 
int tomId = tom.Id;
string bobId = bob.Id;
 
Console.WriteLine(tomId); // 546
Console.WriteLine(bobId); // abc123

class Person<T>
{
    public T Id { get; set; }
    public string Name { get; set; }
    public Person(T id, string name)
    {
        Id = id; 
        Name = name;
    }
}
```

Кроме обобщенных классов можно также создавать **обобщенные методы**, которые точно также будут использовать универсальные параметры. 

```csharp
int x = 7;
int y = 25;
Swap<int>(ref x, ref y); // Swap(ref x, ref y);
Console.WriteLine($"x={x}    y={y}"); // x=25   y=7
 
string s1 = "hello";
string s2 = "bye";
Swap<string>(ref s1, ref s2); // Swap(ref s1, ref s2);
Console.WriteLine($"s1={s1}    s2={s2}"); // s1=bye   s2=hello
 
void Swap<T>(ref T x, ref T y)
{
    T temp = x;
    x = y;
    y = temp;
}
```

15. Ограничения обобщений и их наследование.

В качестве ограничений мы можем использовать следующие типы:

- Классы
- Интерфейсы
- `class` - универсальный параметр должен представлять класс
- `struct` - универсальный параметр должен представлять структуру
- `new()` - универсальный параметр должен представлять тип, который имеет общедоступный (public) конструктор без параметров

Если для универсального параметра задано несколько ограничений, то они должны идти в определенном порядке:

1) Название класса, `class`, `struct`. Причем мы можем одновременно определить только одно из этих ограничений;
2) Название интерфейса;
3) `new()`.

Ограничения обобщенных методов:

```csharp
void SendMessage<T>(T message) where T: Message
{ }
```

Ограничения обобщенных классов:

```csharp
class Messenger<T> where T : Message
{ }
```

Если класс использует несколько универсальных параметров, то последовательно можно задать ограничения к каждому из них:

```csharp
class Messenger<T, P> 
    where T : Message
    where P : Person
{ }
```

Один обобщенный класс может быть унаследован от другого обобщенного. При этом можно использовать различные варианты наследования.

Первый вариант:

```csharp
class UniversalPerson<T> : Person<T>
{
    public UniversalPerson(T id) : base(id) { }
}
```

Второй вариант:

```csharp
class StringPerson : Person<string>
{
    public StringPerson(string id) : base(id) { }
}
```

Третий вариант:

```csharp
class IntPerson<T> : Person<int>
{
    public T Code { get; set; }
    public IntPerson(int id, T code) : base(id) 
    {
        Code = code;
    }
}
```

Стоит учитывать, что если на уровне базового класса для универсального параметра установлено ограничение, то подобное ограничение должно быть определено и в производных классах, которые также используют этот параметр:

```csharp
class Person<T> where T : class
{
    public T Id { get;}
    public Person(T id) => Id = id;
}
class UniversalPerson<T> : Person<T> where T: class
{
    public UniversalPerson(T id) : base(id) { }
}
```

16. Делегаты. Определение, объявление и вызов делегатов. Встроенные делегаты Action\Func\Predicate. Отличия от событий.



```csharp
// CODE
```